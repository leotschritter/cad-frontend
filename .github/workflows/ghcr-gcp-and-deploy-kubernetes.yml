name: Docker push to GHCR and GCP Artifact Registry and deploy Frontend Infrastructure

on:
  push:
    branches: [ "main", "feature/exercise7-leo"  ]
    tags: [ 'v*.*.*' ]
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    environment: Pipeline
    env:
      PROJECT_ID: ${{ vars.PROJECT_ID }}
    permissions:
      contents: read
      packages: write
      id-token: write  # needed for GCP Workload Identity

    outputs:
      frontend_image: ${{ steps.export_image.outputs.frontend_image }}
      app_version: ${{ steps.export_app_version.outputs.app_version }}

    steps:
      - uses: actions/checkout@v4

      # Login to GitHub Container Registry
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Login to Google Artifact Registry
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for GCP
        run: gcloud auth configure-docker europe-west1-docker.pkg.dev

      # Build and push to both registries
      - name: Build and push to GHCR and GCP
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          build-args: |
            VITE_API_BASE_URL=https://api.tripico.fun
            VITE_FIREBASE_API_KEY=${{ vars.VITE_FIREBASE_API_KEY }}
            VITE_FIREBASE_AUTH_DOMAIN=${{ vars.VITE_FIREBASE_AUTH_DOMAIN }}
            VITE_FIREBASE_PROJECT_ID=${{ vars.VITE_FIREBASE_PROJECT_ID }}
          tags: |
            ghcr.io/${{ github.repository }}:latest
            ghcr.io/${{ github.repository }}:${{ github.sha }}
            europe-west1-docker.pkg.dev/${{ vars.PROJECT_ID }}/docker-repo/travel-frontend:latest
            europe-west1-docker.pkg.dev/${{ vars.PROJECT_ID }}/docker-repo/travel-frontend:${{ github.sha }}

      - name: Export image reference
        id: export_image
        run: echo "frontend_image=europe-west1-docker.pkg.dev/${PROJECT_ID}/docker-repo/travel-frontend:${GITHUB_SHA}" >> "$GITHUB_OUTPUT"

      - name: Export app version
        id: export_app_version
        run: echo "app_version=${GITHUB_SHA}" >> "$GITHUB_OUTPUT"
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      # Authenticate again for kubectl
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Install GKE Auth Plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin --quiet

      - name: Configure kubectl for GKE
        run: |
          gcloud container clusters get-credentials tripico-cluster --region europe-west1

      # Install cert-manager for TLS certificate management
      - name: Install cert-manager
        run: |
          echo "Checking if cert-manager is already installed..."
          if kubectl get namespace cert-manager >/dev/null 2>&1 && kubectl get deployment cert-manager -n cert-manager >/dev/null 2>&1; then
            echo "cert-manager is already installed"
          else
            echo "Installing cert-manager..."
            kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml
          fi
          
          echo "Waiting for cert-manager deployments to be ready..."
          kubectl wait --for=condition=Available --timeout=300s \
            deployment/cert-manager -n cert-manager
          kubectl wait --for=condition=Available --timeout=300s \
            deployment/cert-manager-webhook -n cert-manager
          kubectl wait --for=condition=Available --timeout=300s \
            deployment/cert-manager-cainjector -n cert-manager
          
          echo "Checking actual pod labels..."
          kubectl -n cert-manager get pods --show-labels
          
          echo "Waiting for all pods to be ready using correct labels..."
          kubectl wait --for=condition=Ready --timeout=180s \
            pods -l app.kubernetes.io/name=cert-manager -n cert-manager || echo "Main cert-manager pod ready check timed out"
          kubectl wait --for=condition=Ready --timeout=180s \
            pods -l app.kubernetes.io/name=webhook -n cert-manager || echo "Webhook pod ready check timed out"
          kubectl wait --for=condition=Ready --timeout=180s \
            pods -l app.kubernetes.io/name=cainjector -n cert-manager || echo "Cainjector pod ready check timed out"
          
          echo "Checking webhook pod status..."
          kubectl -n cert-manager get pods -l app.kubernetes.io/name=webhook
          kubectl -n cert-manager describe pods -l app.kubernetes.io/name=webhook || true
          
          echo "Waiting additional 60 seconds for webhook TLS certificate generation..."
          sleep 60
          
          echo "Verifying cert-manager webhook is ready..."
          kubectl -n cert-manager logs -l app.kubernetes.io/name=webhook --tail=50 || true

      # Apply cert-manager ClusterIssuers with retry logic
      - name: Apply cert-manager ClusterIssuers
        working-directory: ./k8s
        run: |
          echo "Applying Let's Encrypt ClusterIssuers with retry logic..."
          max_attempts=6
          attempt=1
          success=false
          
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt of $max_attempts..."
            
            if kubectl apply -f cert-manager.yaml 2>&1; then
              echo "✓ Successfully applied ClusterIssuers"
              success=true
              break
            else
              if [ $attempt -lt $max_attempts ]; then
                wait_time=$((15 * attempt))
                echo "✗ Failed to apply ClusterIssuers"
                echo "Waiting ${wait_time} seconds before retry..."
                sleep $wait_time
                
                echo "Checking webhook status..."
                kubectl -n cert-manager get pods -l app.kubernetes.io/name=webhook
                kubectl -n cert-manager describe pods -l app.kubernetes.io/name=webhook | grep -A 10 "Events:" || true
              else
                echo "✗ Failed to apply ClusterIssuers after $max_attempts attempts"
                echo "Dumping cert-manager webhook logs for debugging:"
                kubectl -n cert-manager logs -l app.kubernetes.io/name=webhook --tail=100 || true
                exit 1
              fi
            fi
            attempt=$((attempt + 1))
          done
          
          if [ "$success" = true ]; then
            echo "Verifying ClusterIssuers were created..."
            kubectl get clusterissuers
          fi

      # Install/update ingress-nginx controller
      - name: Install ingress-nginx controller
        run: |
          echo "Installing/updating ingress-nginx controller..."
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
          
          echo "Waiting for ingress-nginx to be ready..."
          kubectl wait --for=condition=Available --timeout=300s \
            deployment/ingress-nginx-controller -n ingress-nginx || echo "Ingress controller may already be running"

      # Create/update secrets and config maps
      - name: Create Firebase secrets
        run: |
          echo "Creating/updating Firebase secrets..."
          kubectl create secret generic firebase-secret \
            --from-literal=VITE_FIREBASE_API_KEY="${{ vars.VITE_FIREBASE_API_KEY }}" \
            --from-literal=VITE_FIREBASE_AUTH_DOMAIN="${{ vars.VITE_FIREBASE_AUTH_DOMAIN }}" \
            --from-literal=VITE_FIREBASE_PROJECT_ID="${{ vars.VITE_FIREBASE_PROJECT_ID }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create frontend config
        run: |
          echo "Creating/updating frontend config..."
          kubectl create configmap cad-frontend-config \
            --from-literal=VITE_API_BASE_URL="https://api.tripico.fun" \
            --dry-run=client -o yaml | kubectl apply -f -

      # Apply application manifests
      - name: Apply Kubernetes Manifests
        working-directory: ./k8s
        run: |
          kubectl apply -f cad-frontend.yaml
          kubectl apply -f ingress-prod.yaml

      # Update deployment image dynamically
      - name: Patch deployment with new image
        run: |
          echo "Updating deployment with new image: ${{ needs.build-and-push.outputs.frontend_image }}"
          kubectl set image deployment/cad-frontend cad-frontend=${{ needs.build-and-push.outputs.frontend_image }}

      - name: Wait for rollout
        run: |
          echo "Waiting for deployment rollout..."
          kubectl rollout status deployment/cad-frontend --timeout=120s

      - name: Show pod status
        run: kubectl get pods -o wide

      # Check certificate status
      - name: Check TLS certificate status
        run: |
          echo "Checking certificate status..."
          sleep 10
          kubectl get certificate -A || echo "No certificates found yet"
          kubectl describe certificate frontend-tripico-fun-tls 2>/dev/null || echo "Certificate not yet created - it may take a few minutes"
          
          echo ""
          echo "=== Deployment Complete ==="
          echo "Frontend should be accessible at: https://frontend.tripico.fun"
          echo "Certificate issuance may take 1-3 minutes if this is the first deployment"

